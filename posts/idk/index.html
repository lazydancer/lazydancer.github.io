---
title: idk
date: 2023-09-01
description: Minecraft inventory bot (deposit & withdraw)
---

<h1 id="title">idk: Automating Storage in Minecraft with Bots, Shulkers, and a Web UI</h1>

<p>
    <a href="https://github.com/lazydancer/idk">View on GitHub</a>
</p>

<p>
    I built <strong>idk</strong> because rummaging through chest halls on a
    multiplayer server was slow and boring. The plan: wire up a Mineflayer bot,
    a small web app, and a pile of shulker boxes so anyone could dump or request
    items without remembering where anything lives.
</p>

<h2>Why a web UI?</h2>
<p>
    In-game signs and books sounded cute until I realised nobody wants to scroll
    through page after page of chest locations. A browser front-end felt obvious
    once I started sketching flows. The Svelte app lists everything in storage,
    lets players search for "mending books" or "stone," and fires an HTTP request
    at the bot service. From there the bot walks to the right chest, grabs the
    stack, and drops it into a delivery barrel near spawn. Deposits work the same
    in reverse.
</p>

<h2>Teaching the bot to move</h2>
<p>
    Storage is just rows of chests stacked six high, laid out so the bot can hop
    between aisles without bumping into redstone. Mineflayer's default pathing
    was close but not reliable, so I added a BFS layer that operates on a trimmed
    voxel map. It caches reachable blocks, refuses jumps that would clip trapdoor
    hinges, and rewinds if a player blocks the aisle mid-run.
</p>

<pre><code class="language-javascript">function findPath(start, target) {
  const queue = [start];
  const visited = new Set([start.key]);

  while (queue.length) {
    const current = queue.shift();
    if (current.key === target.key) return reconstructPath(current);

    for (const neighbor of neighbors(current)) {
      if (!visited.has(neighbor.key) && !neighbor.isBlocked) {
        neighbor.prev = current;
        visited.add(neighbor.key);
        queue.push(neighbor);
      }
    }
  }
  return null;
}
</code></pre>

<h2>Keeping track of every stack</h2>
<p>
    A SQLite database sits behind the web API. Each row stores the item id, item
    count, the chest coordinate, and whether that slot contains a shulker box. On
    deposit the bot updates the record; on withdrawal the web UI shows the new
    count via server-sent events. Nothing beats seeing the numbers tick down while
    the bot jogs back with your netherite scraps.
</p>

<h2>Shulker boxes, the fun part</h2>
<p>
    Bulk moves needed smarter logic. The bot inspects a shulker before moving it,
    fans out the contents into temporary chests, and packs it back together when
    done. Mixed stacks or half-full boxes trigger a small planner that decides
    whether to keep items in place, merge, or crack open another shulker. It is a
    lot of branching for a block that looks like a decorative cube, but it keeps
    the system from filling with half-used containers.
</p>

<h2>Stack choices</h2>
<p>
    TypeScript powers the bot service and Svelte drives the dashboard because I
    wanted type safety on both sides and a lightweight UI. Mineflayer handles the
    Minecraft protocol, Express exposes the API, and a small websocket layer
    streams status updates to whoever requested the items. Building it forced me
    to learn far more about synchronising game state, dealing with tick timing,
    and shipping real tooling for a sandbox game.
</p>

<h2>What I would still tweak</h2>
<p>
    Speed is the obvious next knob to turn--either by caching more routes or by
    dedicating a second bot to run parallel jobs. Bulk exports for building
    projects and a smarter sorter for mixed shulkers are also on the list. Even
    without them, idk has turned storage duty into something I look forward to
    watching instead of doing by hand.
</p>

<img src="fourth.gif" alt="Mineflayer bot sorting items" />
