---
title: Paintball Turret
date: 2014-12-01
description: Autonomous turret built for university mechatronics
---

<h1>Automatic Paintball Turret</h1>

<p>For a mechatronics university course, we had a project to combine our electrical and mechanical knowledge. It was a very broad scope. Our team decided to make an automatic paintball turret, where it would autonomously track and shoot an object. Given how much we spend on it, it worked surprisingly well. In this article, I would like show you a brief overview on what we built and the things we learned.</p>

<p>We broke the work into 2 parts</p>
<ol>
  <li><strong>Mechanical</strong>, which would hold the paintball gun and be able to move it around. It needed to rotate in 3D space, around 90 deg field of view is good enough</li>
  <li><strong>Software</strong> for us to know how to move the turret and when it knows to shoot. This was more on the electronics and software side.</li>
</ol>

<h2 id="mechanical">Mechanical</h2>

<p>In order for the system to orient itself to aim at targets within it's range, two rotational degrees of freedom were required. The first degree of freedom, a rotation about the vertical axis, will be referred to as pan. This aims the barrel of the paintball gun left or right. The second degree of freedom, a rotation about the horizontal axis, will be referred to as tilt. This aims the barrel of the gun up or down. To achieve these degrees of freedom, two motors were required to power the system. To avoid gear alignment and the need for optical encoders, direct drive servo motors were desirable.</p>

<p>For a smooth pan rotation, it was desirable to remove any axial loads acting on the pan motor. For this reason, the weight of the assembly was supported on a large lazy susan bearing oriented for pan rotation. This lazy susan was rated well over the required weight and the square shape made for very easy mounting. The motor was mounted underneath in a non-load- bearing method.</p>

<p>For a smooth tilt rotation, two lubricated bearings were selected to bear any radial loads due to weight, inertia, and recoil that would otherwise transfer directly to the motor. These bearings were sealed to prevent the possible intrusion of paint or dirt and flanged to make for easier mounting. An affordable half inch rod was selected to support all loads. To mount the motor to the shaft, horns were employed to simplify construction and minimize cost of the prototype.</p>

<p>The housing was made out of 1/2" plywood. This selection made manufacturing simple, eliminated the need for a machine shop, and kept the housing relatively light. Before mounting the horns to the housing, the housing was suspended and with the use of a plumb the center of gravity was found to make the movement as smooth as possible. The entire assembly was mounted on a tripod constructed of 3/4" schedule 40 steel piping. This allowed for flexibility in design with readily available materials. The weight of the tripod also provided for a low and stable centre of gravity. If additional mass was required the piping could be filled with sand.</p>

<pre><code>-|- (Gun) -|-
 |         |
 -----------
 (Lazy Susan)
 ------------
   (Tripod)
   /  |   \
</code></pre>

<h2 id="software">Software</h2>

<p>Camera -&gt; Computer -&gt; Arduino -&gt; Stepper Controller -&gt; Stepper Motors -&gt; Turret</p>

<p>We used a webcam which was attached to the base of the paintball gun holder. The camera data was sent to the computer over usb. The computer was running a python program with opencv library. The opencv did the heavy lifting of finding a color and selecting the "glob" with the most area of the camera and found the center, this was the target. We then sent the information to the arduino which converted the message to the stepper motors changing the direction of the paintball gun.</p>

<p>The motor control system receives its input from either the video processing system or the joystick. An Arduino microcontroller receives serial position information over a USB link from PC processing the video. This takes the form of the ASCII character p for pan or t for tilt, followed by a step number between 0 and 1024 to signify the position between 0 and 320 degrees, finalized by a newline character '\n'. An example is p200/n, telling the pan motor to reach 62.5 degrees. The microcontroller ensures the position information is valid then calculates the time the motor has to move to the new position. This was calibrated as 2 milli seconds per change in step. Continuing the example, if pan started at position 300, it would have 200 milliseconds to move to position 200. The Herkulex DRS-0101 motors contain microcontrollers which plot a trapezoidal path between their current and final position. This reduces their peak power draw by ramping up, leveling off, then ramping down near the final position. The internal PID control is further explained in section 3.5. The DRS-0101 communicates over serial communication channel. The original Arduino library written by Alessandro Giacomel from Italy. Support was added for Arduino Due through additional control statements for the different build sections. The Arduino code written for this project will now build for Due, Uno, and all previous Arduinos which support either hardware UART Serial or SoftwareSerial.h.</p>

<p>Target tracking was done by taking visual information from a webcam, processing this visual information and sending a message to the Arduino for the pan and tilt of the servos. The following paragraphs will break down the system that connects these elements. Using the python programming language and opencv, a set of various computer vision functions. The program is set up into 2 parts: initialization; and a loop that runs continuously during operation of the turret.</p>

<h3>Motor PID Controller Tuning</h3>

<p>The HerculeX DRS-0101 comes with a built in PID controller to improve motor control performance. Tuning this controller allowed for better response time, a reduction in overshoot and oscillation, and a minimized steady state error. A PID controller receives an error signal, in this case the difference between the current motor position and the desired motor position, and uses this error to send an ideal output to the motor.</p>

<p>The equation defining the output of a PID controller can be defined as Where e(t) is the error signal, K p is the proportional constant, K i is the integral constant, K d is the derivative constant, and u(t) is the output signal to the motor. The proportional constant, K p , affects the output to the motor based on the current error signal. Increasing this constant will increase the response time of the system but possibly result in overshoot and oscillations.</p>

<p>The integral constant, K i , affects the output based on the current error signal and the duration of error. Meaning that it affects the output based on past errors. Increasing this constant helps to eliminate offset in the steady state error but can lead to a lag in the response. The derivative constant, K d , controls the output based on the slope of the error. In other words, it affects the output to the motor based on future predicted errors. Increasing this constant results in a faster response and improves settling time but is sensitive to high frequencies in the system, for this reason, a low pass filter is required. In this case, the inertia of the system acts as a low pass filter.</p>

<p>As mentioned, the HerculeX motors used in the system have built in PID controllers. The Servo Manager Kit software allows for the adjustment of position K p , position K i , and position K d constants of the motors. Originally, it was planned to employ the Ziegler-Nichols rules for tuning the PID controllers. These are experimental methods for determining PID constants by observing the step response of the system with both integral and derivative constants set to zero</p>

<p>Note that on all vertical axes, the position is in the step units of the motor. After observing the system's response, it seemed satisfactory for our purposes. The system was capable of settling within one second in all cases with very minimal overshoot. For this reason, additional tuning was not done.</p>

<h3>Firing control</h3>

<p>A key design choice made early in the project was selecting a paintball gun with an electronic trigger. This allowed the project to electronically trip the trigger instead of building an additional mechanical system to depress the trigger. Below in Figure 8 is a circuit diagram of the microcontroller and circuit within the Smart Parts Ion PaintBall Gun. Highlighted with the arrow is the mechanical micro switch trigger mechanism. When the switch is depressed pin 15 of the ATMega48v senses connection to ground from the NC connection through the switch. The spring loaded microswitch returns to open when not depressed. The microcontroller will only fire on the falling edge, leaving the trigger depressed will not allow the gun to fire until the microcontroller senses pin high again.</p>

<p>The Arduino Uno used in the final design operates at 5v, while the paintball gun at 3.3v. To compensate for this difference, a voltage divider (as seen in Figure 9) was designed. This was an effective design as power draw by the paintball gun was nonexistent and the Arduino was wall powered, thus losses through the resistors were deemed acceptable.</p>

<p>When you want to aim something but only have the perspective from another object, it is difficult. We wanted to take the webcam image and point the gun at a point in which the camera sees.</p>

<p>First, I tried the simplest approach and assumed they saw the same thing. The shots were off by a lot and it was most noticeable on the edges of the frame.</p>

<p>We needed to get the target in 3D space. First convert the 2D image seen from the camera. It is a 640 x 480 output, from an online source it was found the FOV was 60 Deg and from the aspect ratio of 4:3. X had a view of 48 Deg and the y had a view of 36 Deg</p>

<p>Next, we had to place this point in 3D space, we were missing a distance. Don't tell anyone we just used a constant (10 m). Most things we were going to shoot were far enough to avoid rebound, and it wouldn't be accurate enough to hit anything further.</p>

<p>Now with spherical coordinates now in spherical coordinates we convert to Cartesian to move our origin to get the position relative to the gun. Getting it is simple as adding the difference in the distance between the camera and the gun, shifting the coordinate system</p>

<p>We are not done yet. The motors are looking for angle to be at. We do one more coordinate transformation and send the horizontal angle to the horizontal servo motor and the vertical to the vertical motor.</p>

<h3 id="it-takes-time-to-do-things">It takes time to do things</h3>

<p>It takes time for the motor to move and get up to speed, and it takes time for the projectile to reach its moving target. We needed to predict where the object will be and in what direction we needed to shoot to hit it.</p>

<p>Built in the coordinate transformation function is a target prediction that can be used to estimate where the target will be in a defined period of time. It is using simple linear extrapolation of the position based the targets current velocity, illustrated in Figure 5.</p>

<p>Figure 5: Linear extrapolation of a velocity vector</p>

<p>The velocity is estimated by comparing the current and previous frame and observing how far the centres of the object have moved. Using this distance and the time elapsed, the velocity of the object can be found. To predict the next position the current position is taken and added to the velocity times a defined period of 'leading' time which represents how far ahead we would like to predict. Longer periods of leading time can be used to track fast moving or long-distance targets. However, accuracy will likely decrease with longer leading times.</p>

<p>We had to make some compromises in our code, to bring on the code. We started trying to do most of the calculation on the arduino. That ended quickly when we wanted to use the opencv library.</p>

<p>We had a laptop which was already getting up there in age being 6 years old at the time. It could only process 1 frame per second. We reduced the complexity of the calculation, reduced the camera resolution by half.</p>

<p>The first step is to retrieve a frame from the camera. The camera being used is the Logitech C270 HD Webcam, with a frame displaying 640 by 480 pixels. This gives a total pixel count of 640*480 = 307200 pixels. Each pixel contains 3 numbers to define its state. The frame uses RGB(red, green and blue), each colour is a number between 0 and 255 which fits in one byte. The frame is written to a file and blurred slightly to reduce noise and make contours of greater uniformity.</p>

<h2>Conclusion</h2>

<p>During field testing, the compressed air line and paintballs were added to the paintball sentry. As this additional mass was not accounted for during initial testing and motor tuning, the tilt servo motor was overloaded causing it to stall and eventually caused internal gear damage. Future designs should account for masses added to the gun during use. Additionally, alternate housing designs should be considered to reduce weight. </p>

<p>Future projects should consider using the HerkuleX motor line as their serial communication and internal PID control made for excellent prototyping. </p>

<p>A functional paintball sentry turret was successfully constructed. It successfully tracked targets of a designated color, transformed coordinates of the targets into motor positions, engaged the motors to reorient to aim at the target, and fired paintballs precisely and with reasonable accuracy. With the success a few lessons were learned, the largest being the importance of sizing an adequate motor and balancing the load
</p>
