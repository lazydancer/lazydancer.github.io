---
title: Arrows
date: 2019-09-01
description: Cellular-automata game built from arrow logic
---

<h1>Arrows</h1>

<video width="700" autoplay="" loop="" muted="" playsinline="">
    <source src="output.webm" type="video/webm" />
</video>


<p>The beauty of simple rules creating complex and unique behaviors never ceases to amaze me. In this post, I will be discussing how basic arrows can be combined to create larger logic gates and eventually an adding machine</p>

<p>We will be working with three types of arrows: the normal arrow (<b>&rarr;</b>), the invert arrow (<b>&raquo;</b>), and the divide arrow (<b>&harr;</b>). By combining these arrows, we can create a variety of logic gates, including the OR gate and the NOT gate. While these two gates allow us to create any Boolean expression, having AND and XOR gates makes building even easier</p>

<p>Using DeMorgan's Law, we can create an AND gate using NOT and OR gates. This is equivalent to NOT ((NOT A) OR (NOT B)), and when translated to arrows, it looks like this.</p> 

<img src="and.png" style="width:87px;"/>

<p>The XOR gate is a bit more challenging to create when working with arrows. One of the difficulties is that there is no easy way to cross lines. In a real chip, there are various levels for wires to go around each other, but in a 2D representation like this, that is not possible. Later in the post, I will share my partial solution for creating a XOR gate with arrows. However, I must admit, I took the lazy route and found a solution that uses NOR gates and does not overlap.</p>

<img src="xor_v2.svg" style="height: 150px; margin-right: 160px"/>

<img src="xor.png" style="width:96px"/>

<p>Now we have the basic gates we can combine them to make a simple adder</p>

<h2>Adding Machine</h2>

<p>Addition is a useful thing for computers to do. This can be seen in a computer's arithmetic logic unit which is a central part of a computer's CPU.</p>

<p>We can start building an adder. The truth table is below:</p>

 <table style="width:100%">
  <tr>
    <th>Input A</th>
    <th>Input B</th>
    <th>Output Sum</th>
    <th>Output Carry</th>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
  </tr>
</table> 

<p>The most common half adder design looks like the following. We can't implement this directly as there's no way for us to make the line cross, in red below</p>

<img src="adder.svg" style="height: 130px"/>

<p>To get this to work. I cross lines by taking the XOR of the XOR. I found that the following works: A = XOR(XOR(A, B), B). This function is seen in the arrows below</p>


<img src="adder - updated.svg" style="height: 150px"/>

<p>It takes many arrows for lines to cross by replacing it with that function. I think it would be fun to work on a line reduction function that could take a binary function and reduce the number of line crosses or where it would be cheaper than using 3 xors.I'm sure there is a way to solve this on a boolean algebra side. Even a function that takes a boolean expression and outputs the number of line crosses would allow that to be used in an optimizer function</p>

<p>Converted into arrows:</p>

<img src="half_adder.png" style="width: 319px"/>

<p>Right now we just built a half-adder where the input in missing a carry. We can fix that by adding that. Below is a way of doing that with two half adders and an or gate</p>

<img src="full_adder_2.svg"/>

<p>Using the half adders is useful as we don't have to design another circuit and we can just put half-adder blocks into the new design</p> 

<img src="full_adder.png" style="width: 642px"/>

<p>And finally we can combine 4 full adders to make a 4-bit adder</p>

<img src="4bit adder.png" />

<p>I enjoyed making this and it was a fun challenge. I also learned lots. I hope to pick it up again and try again to make a simple computer. I sure everything could be much smaller and faster than it is. </p>

<p>The game logic runs in Rust with help from ggez; a window management, 2D graphics and event handling library. Written in rust allows for fast simulations of a large number of options. The Rust library is used through a C interface using ccfi in python.</p>

<p>The Python side is where the arrows are being placed. A "Board" object is to rust to be displayed and run. In addition it contains higher level drafter, where more complex boards can be designed. Right now in the drafter, there is a topological function to arrange sub-blocks and a basic router for wires using breadth first search. Some of these I dropped but having the flexibility of trying different things quick is important</p>

<p>If you would like to take a look and run it, it's avalible on <a href="https://github.com/lazydancer/Arrows">github</a></p>
