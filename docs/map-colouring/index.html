<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="icon" href="favicon.ico" type="image/x-icon"/>
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon"/>

  <title>James Pucula - Map Colouring</title>

  <style>@import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap');</style>
  <script>
    (function() {
      try {
        var stored = localStorage.getItem('theme');
        var mediaQuery = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
        var prefersDark = mediaQuery ? mediaQuery.matches : false;
        var theme = stored || (prefersDark ? 'dark' : 'light');
        document.documentElement.dataset.theme = theme;
      } catch (err) {
        document.documentElement.dataset.theme = 'light';
      }
    })();
  </script>
  <link rel = "stylesheet" type="text/css" href="/style.css"/>

</head>
<body>
  <header>
        <a href="/">
  <img width="64" height="64" src="/finch_128.png"></a>
    <button id="theme-toggle" class="theme-toggle" type="button">Dark mode</button>
  </header>

  <main>
<h1>Map Colouring</h1>

<p>Map colouring is a puzzle where you assign different colours to different features ( in this case counties ) on a map with the goal of having no 2 colours share a border. It was first introduced in 1852 to determine the minimum number of colors when trying to colour a map of England. It was postulated that 4 colours were the minimum number of colours to fill a map so that no regions sharing a common border had the same colour.</p>

<img src="English_ceremonial_counties_1998.svg" style="max-width: 500px;" /> 


<p>This problem is called the <a href="https://en.wikipedia.org/wiki/Four_color_theorem">Four color theorem</a> and was the first major theorem to be proved using a computer in 1976.</p>

<p>You can represent the map as a graph, with the counties as nodes and the borders as connections. This type of problem can be generalized and used in other problems such as scheduling, register allocation and pattern matching.</p>

<h2 id="solving">Solving</h2>

<p>As I go through the Discrete Optimization course, I'm learning new techniques to use and get an understanding of the working space of the problem. Like the other problems in this course, this is an NP problem.</p>

<h2 id="brute-force">Brute force</h2>

<p>I would start by trying every single combination and returning the best solution. Computers are great with numbers and I want to be lazy. But looking at the table above there is no way to complete this in a reasonable time.</p>

<p>Small Example, 20 Nodes, 3 Colours, has 3,486,784,401 possible states or 19^9. <strong>2 seconds to solve</strong>*</p> 

<p>Counties of England, 83 Nodes, 4 Colours, has 10^50 possible states<strong>10^36 years to solve</strong>*</p> 

<p>*Assuming 2GHz computer, very optimistically checking 1 combination a cycle</p>


<p>We need another way</p>

<h2 id="pick-most-connected">Pick most connected</h2>

<p>Instead of trying every combination, lets order the way we select the nodes we colour. Starting from the node which has the most connections, choosing its colour and moving to the next, adding a new colour if neighbouring nodes used all the previous colors. This will run until all the colours are chosen</p>

<p>This is so much faster! It is a greedy algorithm so it doesn't give us an optimal result, but the speed is important here. When you add a new node, it adds only a small amount of time and is close to linear.</p>

<h2 id="saturation">Saturation</h2>

<p>This method is very similar to the "most connected" but in this case the next node to select will update each time. When a node is colored the connected nodes are updated with a new saturation number. This saturation number tells how many different colors a node neighbours with. The other name for this algorithm is DSATUR and is a well known algorithm for completing this problem</p>

<h2 id="continuing">Next...</h2>

<p>So far it has been interesting on how large NP problems can get and we have to try different algorithms. A good enough solution is much easier to get than a perfect solution. There is some possibility of using local search to further optimize these solutions.</p>

<p>Thank you for reading</p>
  </main>
  <script>
    (function() {
      var toggle = document.getElementById('theme-toggle');
      if (!toggle) {
        return;
      }

      var root = document.documentElement;

      function currentTheme() {
        return root.dataset.theme === 'dark' ? 'dark' : 'light';
      }

      function updateLabel(theme) {
        var next = theme === 'dark' ? 'light' : 'dark';
        toggle.textContent = next.charAt(0).toUpperCase() + next.slice(1) + ' mode';
        toggle.setAttribute('aria-label', 'Activate ' + next + ' mode');
        toggle.setAttribute('aria-pressed', theme === 'dark' ? 'true' : 'false');
      }

      updateLabel(currentTheme());

      toggle.addEventListener('click', function() {
        var next = currentTheme() === 'dark' ? 'light' : 'dark';
        root.dataset.theme = next;
        try {
          localStorage.setItem('theme', next);
        } catch (err) {
          /* localStorage might be unavailable; ignore */
        }
        updateLabel(next);
      });
    })();
  </script>
  </body>
</html>
