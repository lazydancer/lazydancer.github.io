<html>
<head>
    <title>Pathfinding - James Pucula</title>
    <meta charset='UTF-8'>
    <meta content='width=device-width, initial-scale=1' name='viewport'/>

    <meta name='description' content='James Pucula'>
    <meta name='keywords' content='static, writing'>
    <meta name='author' content='James Pucula'>

    <link href='/css/blog.css' rel='stylesheet'/>
    <link href='/css/trac.css' rel='stylesheet'/>
    <link href='/css/markdown.css' rel='stylesheet'/>

    <script type='text/x-mathjax-config'>
MathJax.Hub.Config({
  jax: ['input/TeX', 'output/HTML-CSS'],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    extensions: ['color.js']
  },
  messageStyle: 'none',
  'HTML-CSS': { preferredFont: 'TeX', availableFonts: ['STIX','TeX'] }
});
</script>

<script src='//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML' type='text/javascript'></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
</head>
<body>
<div class='content'>
    <div class='nav'>
    <ul class='wrap'>
        <li><a href='/'><img src='/assets/logo.png'></img></a></a></li>
    </ul>
</div>
    <div class='front-matter'>
        <div class='wrap'>
            <h1>Pathfinding</h1>
            <h4>A quick intro to pathfinding with videos</h4>
            <div class='bylines'>
                <div class='byline'>
                    <h3>Published</h3>
                    <p>30 May 2019</p>
                </div>
                <div class='byline'>
                    <h3>Updated</h3>
                    <p>01 June 2020</p>
                </div>
            </div>
            <div class='clear'></div>
        </div>
    </div>
    <div class='wrap article'>
        <p>I’ve run into a challenge were I want to connect blocks together using paths. The paths can’t overlap and the algorithm needs to run fast as there are a lot of them. In this article I wanted to show how I solved this problem using pathfinding. Also looking at the different trade-offs in speed, memory and “solution idealness” of the different approachs to take when pathfinding.</p>

<h2 id="random-walk-depth-first">Random Walk</h2>

<p>Each of the following algorithms require two variables. <strong>Visited</strong>, a list of visited locations, in dark blue in the animations and <strong>Queue</strong> a list of elements to be visited next, in light blue in the animantions below. To start off with the most simple to explain is random walk. Grab the location from the next in queue, add the neighbours to the front of the queue in random order and repeat until you land on your destination.</p>

<div class="figure">
    <video autoplay="" loop="" style="display: block; margin: 0 auto;">
        <source src="/assets/pathfinding/depth.webm" type="video/webm" />
    </video>
    <div class="caption">
        <span class="caption-label">Figure 2.</span> Depth first search. Visited in blue, queue in light blue and discovered path in dark blue.
    </div>
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">:</span>
    <span class="n">vertex</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nb">next</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">vertex</span> <span class="ow">is</span> <span class="n">at</span> <span class="n">destination</span><span class="p">:</span> <span class="k">return</span> <span class="n">vertex</span><span class="p">.</span><span class="n">path</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">add_to_front</span><span class="p">(</span><span class="n">vertex</span><span class="p">.</span><span class="n">neighbours</span><span class="p">)</span>
    <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
</code></pre></div></div>

<p>This is an effective algorithm for small problems where any path will do. It has the benefit of being very simple to implement and can be faster to find a solution than a breadth-first search.</p>

<h2 id="brute-force-breadth-first">Brute Force (Breadth-First)</h2>

<p>If the optimal path is needed, you need to check each possible path and return the first path which finds the destination. This is very similar to brute-force in a combinatoric problem.</p>

<div class="figure">
    <video autoplay="" loop="" style="display: block; margin: 0 auto;">
        <source src="/assets/pathfinding/breadth.webm" type="video/webm" />
    </video>
    <div class="caption">
        <span class="caption-label">Figure 3.</span> Breadth-first search. Visited in blue, queue in light blue and discovered path in dark blue.
    </div>
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">:</span>
    <span class="n">vertex</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nb">next</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">vertex</span> <span class="ow">is</span> <span class="n">at</span> <span class="n">destination</span><span class="p">:</span> <span class="k">return</span> <span class="n">vertex</span><span class="p">.</span><span class="n">path</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">add_to_end</span><span class="p">(</span><span class="n">vertex</span><span class="p">.</span><span class="n">neighbours</span><span class="p">)</span>
    <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
</code></pre></div></div>

<p>Instead of adding new neighbours to the front of the queue they are put at the end. This ensures we have visited all the neighbours before we introduce new ones.</p>

<p>This algorithm finds the best path through taking a step in each direction until it lands on the solution.</p>

<p>To improve the algorithm, each “step” is not always equal. An algorithm where we can change the value of each step is called Dijkstra’s algorithm.</p>

<h2 id="flexibility-from-dijkstra">Flexibility from (Dijkstra)</h2>

<p>The same as above, we are going to explicitly define how far we have travelled. This allows us to vary the “weight” of moving from one location to another.</p>

<p>In the code below, I added a weight variable in each element in the queue. This will be used to compare what location to check next.</p>

<p>In this case, with a step being “1”, the results are exactly the same as breadth-first search. Replacing this value will change which locations are visited first.</p>

<p>Instead of taking a step in every direction, what if we could take a step in the direction towards our target?</p>

<h2 id="with-a-little-help-from-a-heuristic-best-first">With a Little Help From A Heuristic (Best-First)</h2>

<p>In this algorithm, we look at all of the neighbours that have been added to the queue and go to the one that is closest to the final solution. Closest refering to the linear distance between the location and the target.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">distance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</code></pre></div></div>

<p>In some cases this is the best solution, but when a wall is between the start and the destination, the solution is not optimal as the path walks into a wall than has to back up.</p>

<div class="figure">
    <video autoplay="" loop="" style="display: block; margin: 0 auto;">
        <source src="/assets/pathfinding/best.webm" type="video/webm" />
    </video>
    <div class="caption">
        <span class="caption-label">Figure 4.</span> Heuristic search. Visited in blue, queue in light blue and discovered path in dark blue.
    </div>
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">:</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">sort_by_distance</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
    <span class="n">vertex</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nb">next</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">vertex</span> <span class="ow">is</span> <span class="n">at</span> <span class="n">destination</span><span class="p">:</span> <span class="k">return</span> <span class="n">vertex</span><span class="p">.</span><span class="n">path</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">.</span><span class="n">neighbours</span><span class="p">)</span>
    <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
</code></pre></div></div>

<p>To change this from Dijkstra’s algorithm, instead of ordering the queue by “weight distance”, you order the queue by distance from the destination with the closest being at the front of the queue.</p>

<h2 id="mix-for-taste-a">Mix For Taste (A*)</h2>

<p>We can balance the idealness of Dijkstra’s algorithm with the speed of the Best-First search by combining both metrics for ordering the queue.</p>

<p>When determining the queue order, both the weight from the start and the distance to the destination are used.</p>

<div class="figure">
    <video autoplay="" loop="" style="display: block; margin: 0 auto;">
        <source src="/assets/pathfinding/astar.webm" type="video/webm" />
    </video>
    <div class="caption">
        <span class="caption-label">Figure 5.</span> A* search. Visited in blue, queue in light blue and discovered path in dark blue.
    </div>
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">:</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">sort_by_distance_and_recentness</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
    <span class="n">vertex</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nb">next</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">vertex</span> <span class="ow">is</span> <span class="n">at</span> <span class="n">destination</span><span class="p">:</span> <span class="k">return</span> <span class="n">vertex</span><span class="p">.</span><span class="n">path</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">.</span><span class="n">neighbours</span><span class="p">)</span>
    <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
</code></pre></div></div>

<p>This balance directs the search while looking at multiple solutions in that direction to find a close to ideal solution.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Pathfinding is an important method in connecting two nodes in a network. Networks are found everywhere. From the chemical reaction pathways inside a cell, transportion systems, and to the trade and political networks that shape our world.</p>

<p>These algorithms give an introduction to the costs and benefits of each to help solve real challenges in these networks. Thank you for reading. If you enjoyed this post, I would recommend checking out my post on <a href="https://pucula.com/map-colouring.html">Map Coloring</a>. Also, I have posted all of the code on <a href="https://github.com/lazydancer/path-finding">github</a></p>

    </div>
    <div id='bibliography'>
        <div class='wrap'>
            <ol class="bibliography"></ol>
        </div>
    </div>
</div>
</body>
</html>
